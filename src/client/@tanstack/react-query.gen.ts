// This file is auto-generated by @hey-api/openapi-ts

import {
  type Options,
  newEvent,
  paginatedAll,
  searchByPerimeter,
  searchByPerimeterCount,
  searchByAddress,
  searchByAddressCount,
  getMultipleEventById,
  deleteEvent,
  getEventById,
  updateEvent,
  getEventOrganizer,
  fetchNotifications,
  allEventTypes,
  newEventType,
  getEventTypeById,
  updateEventType,
  deleteEventTypeById,
  getCreateCountries,
  getSearchCountries,
  newSource,
  allSources,
  searchSource,
  getSourceById,
  updateSource,
  getSourceAdminsById,
  getSourceContactById,
  updateSourceAdmin,
  addSourceAdmin,
  removeSourceAdmin,
  futureEvents,
  pastEvents,
  editableEvents,
  getSourceTitleImage,
  upsertTitleImage,
  allSourceTypes,
  newSourceType,
  getSourceTypeById,
  updateSourceType,
  deleteSourceTypeById,
  allTopics,
  newTopic,
  updateTopic,
  deleteTopicById,
  getTopicById,
  allInformation,
  newInformation,
  getAvailableCities,
  findInformation,
  deleteInformation,
  updateInformation,
  getAccessTokenByLogin,
  getAccessTokenByToken,
  resetPassword,
  deleteOwnUser,
  getOwnUser,
  updateOwnUser,
  getOwnSources,
  getAdminIds,
  makeAdmin,
  getUserById,
  updateUserById,
  getSearchLanguages,
  getAvailableDocuments,
  deleteDocumentById,
  getDocumentById,
  uploadDocument,
  getEventAnalysis,
  readApplicationSettings,
  updateApplicationSettings,
  getAdminStatistics,
  runCleanup,
  train,
  getQuickTagEvent,
  quickTagEvent,
  uploadExcel,
  dumpEvents,
  getEventIcs,
  getEventsIcs,
  getRssFeed,
  getStaticsSitemap,
  getSourcesSitemap,
  getEventsSitemapIndex,
  getEventsSitemap,
} from '../sdk.gen';
import {
  queryOptions,
  type UseMutationOptions,
  infiniteQueryOptions,
  type InfiniteData,
  type DefaultError,
} from '@tanstack/react-query';
import type {
  NewEventData,
  NewEventError,
  NewEventResponse,
  PaginatedAllData,
  PaginatedAllError,
  PaginatedAllResponse,
  SearchByPerimeterData,
  SearchByPerimeterError,
  SearchByPerimeterResponse,
  SearchByPerimeterCountData,
  SearchByPerimeterCountError,
  SearchByPerimeterCountResponse,
  SearchByAddressData,
  SearchByAddressError,
  SearchByAddressResponse,
  SearchByAddressCountData,
  SearchByAddressCountError,
  SearchByAddressCountResponse,
  GetMultipleEventByIdData,
  GetMultipleEventByIdError,
  GetMultipleEventByIdResponse,
  DeleteEventData,
  DeleteEventError,
  DeleteEventResponse,
  GetEventByIdData,
  UpdateEventData,
  UpdateEventError,
  UpdateEventResponse,
  GetEventOrganizerData,
  FetchNotificationsData,
  FetchNotificationsError,
  FetchNotificationsResponse,
  AllEventTypesData,
  NewEventTypeData,
  NewEventTypeError,
  NewEventTypeResponse,
  GetEventTypeByIdData,
  UpdateEventTypeData,
  UpdateEventTypeError,
  UpdateEventTypeResponse,
  DeleteEventTypeByIdData,
  DeleteEventTypeByIdError,
  DeleteEventTypeByIdResponse,
  GetCreateCountriesData,
  GetSearchCountriesData,
  NewSourceData,
  NewSourceError,
  NewSourceResponse,
  AllSourcesData,
  AllSourcesError,
  AllSourcesResponse,
  SearchSourceData,
  SearchSourceError,
  SearchSourceResponse,
  GetSourceByIdData,
  UpdateSourceData,
  UpdateSourceError,
  UpdateSourceResponse,
  GetSourceAdminsByIdData,
  GetSourceContactByIdData,
  UpdateSourceAdminData,
  UpdateSourceAdminError,
  UpdateSourceAdminResponse,
  AddSourceAdminData,
  AddSourceAdminError,
  AddSourceAdminResponse,
  RemoveSourceAdminData,
  RemoveSourceAdminError,
  RemoveSourceAdminResponse,
  FutureEventsData,
  FutureEventsError,
  FutureEventsResponse,
  PastEventsData,
  PastEventsError,
  PastEventsResponse,
  EditableEventsData,
  EditableEventsError,
  EditableEventsResponse,
  GetSourceTitleImageData,
  UpsertTitleImageData,
  UpsertTitleImageError,
  UpsertTitleImageResponse,
  AllSourceTypesData,
  NewSourceTypeData,
  NewSourceTypeError,
  NewSourceTypeResponse,
  GetSourceTypeByIdData,
  UpdateSourceTypeData,
  UpdateSourceTypeError,
  UpdateSourceTypeResponse,
  DeleteSourceTypeByIdData,
  DeleteSourceTypeByIdError,
  DeleteSourceTypeByIdResponse,
  AllTopicsData,
  NewTopicData,
  NewTopicError,
  NewTopicResponse,
  UpdateTopicData,
  UpdateTopicError,
  UpdateTopicResponse,
  DeleteTopicByIdData,
  DeleteTopicByIdError,
  DeleteTopicByIdResponse,
  GetTopicByIdData,
  AllInformationData,
  AllInformationResponse,
  NewInformationData,
  NewInformationError,
  NewInformationResponse,
  GetAvailableCitiesData,
  FindInformationData,
  FindInformationError,
  FindInformationResponse,
  DeleteInformationData,
  DeleteInformationError,
  DeleteInformationResponse,
  UpdateInformationData,
  UpdateInformationError,
  UpdateInformationResponse,
  GetAccessTokenByLoginData,
  GetAccessTokenByLoginError,
  GetAccessTokenByLoginResponse,
  GetAccessTokenByTokenData,
  ResetPasswordData,
  ResetPasswordError,
  ResetPasswordResponse,
  DeleteOwnUserData,
  DeleteOwnUserResponse,
  GetOwnUserData,
  UpdateOwnUserData,
  UpdateOwnUserError,
  UpdateOwnUserResponse,
  GetOwnSourcesData,
  GetAdminIdsData,
  MakeAdminData,
  MakeAdminError,
  MakeAdminResponse,
  GetUserByIdData,
  UpdateUserByIdData,
  UpdateUserByIdError,
  UpdateUserByIdResponse,
  GetSearchLanguagesData,
  GetAvailableDocumentsData,
  DeleteDocumentByIdData,
  DeleteDocumentByIdError,
  DeleteDocumentByIdResponse,
  GetDocumentByIdData,
  UploadDocumentData,
  UploadDocumentError,
  UploadDocumentResponse,
  GetEventAnalysisData,
  GetEventAnalysisError,
  GetEventAnalysisResponse,
  ReadApplicationSettingsData,
  UpdateApplicationSettingsData,
  UpdateApplicationSettingsError,
  UpdateApplicationSettingsResponse,
  GetAdminStatisticsData,
  GetAdminStatisticsResponse,
  RunCleanupData,
  RunCleanupError,
  RunCleanupResponse,
  TrainData,
  GetQuickTagEventData,
  GetQuickTagEventError,
  GetQuickTagEventResponse,
  QuickTagEventData,
  QuickTagEventError,
  QuickTagEventResponse,
  UploadExcelData,
  UploadExcelError,
  UploadExcelResponse,
  DumpEventsData,
  GetEventIcsData,
  GetEventsIcsData,
  GetEventsIcsError,
  GetEventsIcsResponse,
  GetRssFeedData,
  GetRssFeedError,
  GetStaticsSitemapData,
  GetSourcesSitemapData,
  GetEventsSitemapIndexData,
  GetEventsSitemapData,
} from '../types.gen';
import { client as _heyApiClient } from '../client.gen';

export type QueryKey<TOptions extends Options> = [
  Pick<TOptions, 'baseUrl' | 'body' | 'headers' | 'path' | 'query'> & {
    _id: string;
    _infinite?: boolean;
  },
];

const createQueryKey = <TOptions extends Options>(
  id: string,
  options?: TOptions,
  infinite?: boolean
): [QueryKey<TOptions>[0]] => {
  const params: QueryKey<TOptions>[0] = {
    _id: id,
    baseUrl: (options?.client ?? _heyApiClient).getConfig().baseUrl,
  } as QueryKey<TOptions>[0];
  if (infinite) {
    params._infinite = infinite;
  }
  if (options?.body) {
    params.body = options.body;
  }
  if (options?.headers) {
    params.headers = options.headers;
  }
  if (options?.path) {
    params.path = options.path;
  }
  if (options?.query) {
    params.query = options.query;
  }
  return [params];
};

export const newEventQueryKey = (options: Options<NewEventData>) =>
  createQueryKey('newEvent', options);

/**
 * New Event
 * Create a new event.
 */
export const newEventOptions = (options: Options<NewEventData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await newEvent({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: newEventQueryKey(options),
  });
};

/**
 * New Event
 * Create a new event.
 */
export const newEventMutation = (
  options?: Partial<Options<NewEventData>>
): UseMutationOptions<
  NewEventResponse,
  NewEventError,
  Options<NewEventData>
> => {
  const mutationOptions: UseMutationOptions<
    NewEventResponse,
    NewEventError,
    Options<NewEventData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await newEvent({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const paginatedAllQueryKey = (options: Options<PaginatedAllData>) =>
  createQueryKey('paginatedAll', options);

/**
 * Paginated All
 * Get all events for a paginated view.
 */
export const paginatedAllOptions = (options: Options<PaginatedAllData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await paginatedAll({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: paginatedAllQueryKey(options),
  });
};

const createInfiniteParams = <
  K extends Pick<QueryKey<Options>[0], 'body' | 'headers' | 'path' | 'query'>,
>(
  queryKey: QueryKey<Options>,
  page: K
) => {
  const params = {
    ...queryKey[0],
  };
  if (page.body) {
    params.body = {
      ...(queryKey[0].body as any),
      ...(page.body as any),
    };
  }
  if (page.headers) {
    params.headers = {
      ...queryKey[0].headers,
      ...page.headers,
    };
  }
  if (page.path) {
    params.path = {
      ...(queryKey[0].path as any),
      ...(page.path as any),
    };
  }
  if (page.query) {
    params.query = {
      ...(queryKey[0].query as any),
      ...(page.query as any),
    };
  }
  return params as unknown as typeof page;
};

export const paginatedAllInfiniteQueryKey = (
  options: Options<PaginatedAllData>
): QueryKey<Options<PaginatedAllData>> =>
  createQueryKey('paginatedAll', options, true);

/**
 * Paginated All
 * Get all events for a paginated view.
 */
export const paginatedAllInfiniteOptions = (
  options: Options<PaginatedAllData>
) => {
  return infiniteQueryOptions<
    PaginatedAllResponse,
    PaginatedAllError,
    InfiniteData<PaginatedAllResponse>,
    QueryKey<Options<PaginatedAllData>>,
    | number
    | Pick<
        QueryKey<Options<PaginatedAllData>>[0],
        'body' | 'headers' | 'path' | 'query'
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<PaginatedAllData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                body: {
                  offset: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await paginatedAll({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: paginatedAllInfiniteQueryKey(options),
    }
  );
};

/**
 * Paginated All
 * Get all events for a paginated view.
 */
export const paginatedAllMutation = (
  options?: Partial<Options<PaginatedAllData>>
): UseMutationOptions<
  PaginatedAllResponse,
  PaginatedAllError,
  Options<PaginatedAllData>
> => {
  const mutationOptions: UseMutationOptions<
    PaginatedAllResponse,
    PaginatedAllError,
    Options<PaginatedAllData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await paginatedAll({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const searchByPerimeterQueryKey = (
  options: Options<SearchByPerimeterData>
) => createQueryKey('searchByPerimeter', options);

/**
 * Search By Perimeter
 * Search events within a radius around a point.
 */
export const searchByPerimeterOptions = (
  options: Options<SearchByPerimeterData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await searchByPerimeter({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: searchByPerimeterQueryKey(options),
  });
};

export const searchByPerimeterInfiniteQueryKey = (
  options: Options<SearchByPerimeterData>
): QueryKey<Options<SearchByPerimeterData>> =>
  createQueryKey('searchByPerimeter', options, true);

/**
 * Search By Perimeter
 * Search events within a radius around a point.
 */
export const searchByPerimeterInfiniteOptions = (
  options: Options<SearchByPerimeterData>
) => {
  return infiniteQueryOptions<
    SearchByPerimeterResponse,
    SearchByPerimeterError,
    InfiniteData<SearchByPerimeterResponse>,
    QueryKey<Options<SearchByPerimeterData>>,
    | number
    | Pick<
        QueryKey<Options<SearchByPerimeterData>>[0],
        'body' | 'headers' | 'path' | 'query'
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<SearchByPerimeterData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                body: {
                  offset: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await searchByPerimeter({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: searchByPerimeterInfiniteQueryKey(options),
    }
  );
};

/**
 * Search By Perimeter
 * Search events within a radius around a point.
 */
export const searchByPerimeterMutation = (
  options?: Partial<Options<SearchByPerimeterData>>
): UseMutationOptions<
  SearchByPerimeterResponse,
  SearchByPerimeterError,
  Options<SearchByPerimeterData>
> => {
  const mutationOptions: UseMutationOptions<
    SearchByPerimeterResponse,
    SearchByPerimeterError,
    Options<SearchByPerimeterData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await searchByPerimeter({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const searchByPerimeterCountQueryKey = (
  options: Options<SearchByPerimeterCountData>
) => createQueryKey('searchByPerimeterCount', options);

/**
 * Search By Perimeter Count
 * Get the number of events within a radius around a point.
 */
export const searchByPerimeterCountOptions = (
  options: Options<SearchByPerimeterCountData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await searchByPerimeterCount({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: searchByPerimeterCountQueryKey(options),
  });
};

export const searchByPerimeterCountInfiniteQueryKey = (
  options: Options<SearchByPerimeterCountData>
): QueryKey<Options<SearchByPerimeterCountData>> =>
  createQueryKey('searchByPerimeterCount', options, true);

/**
 * Search By Perimeter Count
 * Get the number of events within a radius around a point.
 */
export const searchByPerimeterCountInfiniteOptions = (
  options: Options<SearchByPerimeterCountData>
) => {
  return infiniteQueryOptions<
    SearchByPerimeterCountResponse,
    SearchByPerimeterCountError,
    InfiniteData<SearchByPerimeterCountResponse>,
    QueryKey<Options<SearchByPerimeterCountData>>,
    | number
    | Pick<
        QueryKey<Options<SearchByPerimeterCountData>>[0],
        'body' | 'headers' | 'path' | 'query'
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<SearchByPerimeterCountData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                body: {
                  offset: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await searchByPerimeterCount({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: searchByPerimeterCountInfiniteQueryKey(options),
    }
  );
};

/**
 * Search By Perimeter Count
 * Get the number of events within a radius around a point.
 */
export const searchByPerimeterCountMutation = (
  options?: Partial<Options<SearchByPerimeterCountData>>
): UseMutationOptions<
  SearchByPerimeterCountResponse,
  SearchByPerimeterCountError,
  Options<SearchByPerimeterCountData>
> => {
  const mutationOptions: UseMutationOptions<
    SearchByPerimeterCountResponse,
    SearchByPerimeterCountError,
    Options<SearchByPerimeterCountData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await searchByPerimeterCount({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const searchByAddressQueryKey = (
  options: Options<SearchByAddressData>
) => createQueryKey('searchByAddress', options);

/**
 * Search By Address
 * Search events with a certain address.
 */
export const searchByAddressOptions = (
  options: Options<SearchByAddressData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await searchByAddress({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: searchByAddressQueryKey(options),
  });
};

export const searchByAddressInfiniteQueryKey = (
  options: Options<SearchByAddressData>
): QueryKey<Options<SearchByAddressData>> =>
  createQueryKey('searchByAddress', options, true);

/**
 * Search By Address
 * Search events with a certain address.
 */
export const searchByAddressInfiniteOptions = (
  options: Options<SearchByAddressData>
) => {
  return infiniteQueryOptions<
    SearchByAddressResponse,
    SearchByAddressError,
    InfiniteData<SearchByAddressResponse>,
    QueryKey<Options<SearchByAddressData>>,
    | number
    | Pick<
        QueryKey<Options<SearchByAddressData>>[0],
        'body' | 'headers' | 'path' | 'query'
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<SearchByAddressData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                body: {
                  offset: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await searchByAddress({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: searchByAddressInfiniteQueryKey(options),
    }
  );
};

/**
 * Search By Address
 * Search events with a certain address.
 */
export const searchByAddressMutation = (
  options?: Partial<Options<SearchByAddressData>>
): UseMutationOptions<
  SearchByAddressResponse,
  SearchByAddressError,
  Options<SearchByAddressData>
> => {
  const mutationOptions: UseMutationOptions<
    SearchByAddressResponse,
    SearchByAddressError,
    Options<SearchByAddressData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await searchByAddress({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const searchByAddressCountQueryKey = (
  options: Options<SearchByAddressCountData>
) => createQueryKey('searchByAddressCount', options);

/**
 * Search By Address Count
 * Get the number of events with a certain address.
 */
export const searchByAddressCountOptions = (
  options: Options<SearchByAddressCountData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await searchByAddressCount({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: searchByAddressCountQueryKey(options),
  });
};

export const searchByAddressCountInfiniteQueryKey = (
  options: Options<SearchByAddressCountData>
): QueryKey<Options<SearchByAddressCountData>> =>
  createQueryKey('searchByAddressCount', options, true);

/**
 * Search By Address Count
 * Get the number of events with a certain address.
 */
export const searchByAddressCountInfiniteOptions = (
  options: Options<SearchByAddressCountData>
) => {
  return infiniteQueryOptions<
    SearchByAddressCountResponse,
    SearchByAddressCountError,
    InfiniteData<SearchByAddressCountResponse>,
    QueryKey<Options<SearchByAddressCountData>>,
    | number
    | Pick<
        QueryKey<Options<SearchByAddressCountData>>[0],
        'body' | 'headers' | 'path' | 'query'
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<SearchByAddressCountData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                body: {
                  offset: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await searchByAddressCount({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: searchByAddressCountInfiniteQueryKey(options),
    }
  );
};

/**
 * Search By Address Count
 * Get the number of events with a certain address.
 */
export const searchByAddressCountMutation = (
  options?: Partial<Options<SearchByAddressCountData>>
): UseMutationOptions<
  SearchByAddressCountResponse,
  SearchByAddressCountError,
  Options<SearchByAddressCountData>
> => {
  const mutationOptions: UseMutationOptions<
    SearchByAddressCountResponse,
    SearchByAddressCountError,
    Options<SearchByAddressCountData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await searchByAddressCount({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getMultipleEventByIdQueryKey = (
  options: Options<GetMultipleEventByIdData>
) => createQueryKey('getMultipleEventById', options);

/**
 * Get Multiple Event By Id
 * Get an event by ID.
 */
export const getMultipleEventByIdOptions = (
  options: Options<GetMultipleEventByIdData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getMultipleEventById({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getMultipleEventByIdQueryKey(options),
  });
};

/**
 * Get Multiple Event By Id
 * Get an event by ID.
 */
export const getMultipleEventByIdMutation = (
  options?: Partial<Options<GetMultipleEventByIdData>>
): UseMutationOptions<
  GetMultipleEventByIdResponse,
  GetMultipleEventByIdError,
  Options<GetMultipleEventByIdData>
> => {
  const mutationOptions: UseMutationOptions<
    GetMultipleEventByIdResponse,
    GetMultipleEventByIdError,
    Options<GetMultipleEventByIdData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await getMultipleEventById({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete Event
 * Delete an event by ID.
 */
export const deleteEventMutation = (
  options?: Partial<Options<DeleteEventData>>
): UseMutationOptions<
  DeleteEventResponse,
  DeleteEventError,
  Options<DeleteEventData>
> => {
  const mutationOptions: UseMutationOptions<
    DeleteEventResponse,
    DeleteEventError,
    Options<DeleteEventData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await deleteEvent({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getEventByIdQueryKey = (options: Options<GetEventByIdData>) =>
  createQueryKey('getEventById', options);

/**
 * Get Event By Id
 * Get an event by ID.
 */
export const getEventByIdOptions = (options: Options<GetEventByIdData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getEventById({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getEventByIdQueryKey(options),
  });
};

/**
 * Update Event
 * Update an event by ID.
 */
export const updateEventMutation = (
  options?: Partial<Options<UpdateEventData>>
): UseMutationOptions<
  UpdateEventResponse,
  UpdateEventError,
  Options<UpdateEventData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateEventResponse,
    UpdateEventError,
    Options<UpdateEventData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await updateEvent({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getEventOrganizerQueryKey = (
  options: Options<GetEventOrganizerData>
) => createQueryKey('getEventOrganizer', options);

/**
 * Get Event Organizer
 * Get an events organising source.
 */
export const getEventOrganizerOptions = (
  options: Options<GetEventOrganizerData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getEventOrganizer({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getEventOrganizerQueryKey(options),
  });
};

export const fetchNotificationsQueryKey = (
  options: Options<FetchNotificationsData>
) => createQueryKey('fetchNotifications', options);

/**
 * Fetch Notifications
 * Get a list of notifications to show the user.
 */
export const fetchNotificationsOptions = (
  options: Options<FetchNotificationsData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await fetchNotifications({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: fetchNotificationsQueryKey(options),
  });
};

/**
 * Fetch Notifications
 * Get a list of notifications to show the user.
 */
export const fetchNotificationsMutation = (
  options?: Partial<Options<FetchNotificationsData>>
): UseMutationOptions<
  FetchNotificationsResponse,
  FetchNotificationsError,
  Options<FetchNotificationsData>
> => {
  const mutationOptions: UseMutationOptions<
    FetchNotificationsResponse,
    FetchNotificationsError,
    Options<FetchNotificationsData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await fetchNotifications({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const allEventTypesQueryKey = (options?: Options<AllEventTypesData>) =>
  createQueryKey('allEventTypes', options);

/**
 * All Event Types
 * Get all event types.
 */
export const allEventTypesOptions = (options?: Options<AllEventTypesData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await allEventTypes({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: allEventTypesQueryKey(options),
  });
};

export const newEventTypeQueryKey = (options: Options<NewEventTypeData>) =>
  createQueryKey('newEventType', options);

/**
 * New Event Type
 * Create a new event type.
 */
export const newEventTypeOptions = (options: Options<NewEventTypeData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await newEventType({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: newEventTypeQueryKey(options),
  });
};

/**
 * New Event Type
 * Create a new event type.
 */
export const newEventTypeMutation = (
  options?: Partial<Options<NewEventTypeData>>
): UseMutationOptions<
  NewEventTypeResponse,
  NewEventTypeError,
  Options<NewEventTypeData>
> => {
  const mutationOptions: UseMutationOptions<
    NewEventTypeResponse,
    NewEventTypeError,
    Options<NewEventTypeData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await newEventType({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getEventTypeByIdQueryKey = (
  options: Options<GetEventTypeByIdData>
) => createQueryKey('getEventTypeById', options);

/**
 * Get Event Type By Id
 * Get an event type by ID.
 */
export const getEventTypeByIdOptions = (
  options: Options<GetEventTypeByIdData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getEventTypeById({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getEventTypeByIdQueryKey(options),
  });
};

/**
 * Update Event Type
 * Update an event type by ID.
 */
export const updateEventTypeMutation = (
  options?: Partial<Options<UpdateEventTypeData>>
): UseMutationOptions<
  UpdateEventTypeResponse,
  UpdateEventTypeError,
  Options<UpdateEventTypeData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateEventTypeResponse,
    UpdateEventTypeError,
    Options<UpdateEventTypeData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await updateEventType({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete Event Type By Id
 * Delete an event type by ID.
 */
export const deleteEventTypeByIdMutation = (
  options?: Partial<Options<DeleteEventTypeByIdData>>
): UseMutationOptions<
  DeleteEventTypeByIdResponse,
  DeleteEventTypeByIdError,
  Options<DeleteEventTypeByIdData>
> => {
  const mutationOptions: UseMutationOptions<
    DeleteEventTypeByIdResponse,
    DeleteEventTypeByIdError,
    Options<DeleteEventTypeByIdData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await deleteEventTypeById({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getCreateCountriesQueryKey = (
  options?: Options<GetCreateCountriesData>
) => createQueryKey('getCreateCountries', options);

/**
 * Get Create Countries
 * List all countries for which are information can be created.
 */
export const getCreateCountriesOptions = (
  options?: Options<GetCreateCountriesData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getCreateCountries({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getCreateCountriesQueryKey(options),
  });
};

export const getSearchCountriesQueryKey = (
  options?: Options<GetSearchCountriesData>
) => createQueryKey('getSearchCountries', options);

/**
 * Get Search Countries
 * List all countries for which are information available.
 */
export const getSearchCountriesOptions = (
  options?: Options<GetSearchCountriesData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getSearchCountries({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getSearchCountriesQueryKey(options),
  });
};

export const newSourceQueryKey = (options: Options<NewSourceData>) =>
  createQueryKey('newSource', options);

/**
 * New Source
 * Create a new source.
 */
export const newSourceOptions = (options: Options<NewSourceData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await newSource({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: newSourceQueryKey(options),
  });
};

/**
 * New Source
 * Create a new source.
 */
export const newSourceMutation = (
  options?: Partial<Options<NewSourceData>>
): UseMutationOptions<
  NewSourceResponse,
  NewSourceError,
  Options<NewSourceData>
> => {
  const mutationOptions: UseMutationOptions<
    NewSourceResponse,
    NewSourceError,
    Options<NewSourceData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await newSource({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const allSourcesQueryKey = (options?: Options<AllSourcesData>) =>
  createQueryKey('allSources', options);

/**
 * All Sources
 * Get all sources.
 */
export const allSourcesOptions = (options?: Options<AllSourcesData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await allSources({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: allSourcesQueryKey(options),
  });
};

export const allSourcesInfiniteQueryKey = (
  options?: Options<AllSourcesData>
): QueryKey<Options<AllSourcesData>> =>
  createQueryKey('allSources', options, true);

/**
 * All Sources
 * Get all sources.
 */
export const allSourcesInfiniteOptions = (
  options?: Options<AllSourcesData>
) => {
  return infiniteQueryOptions<
    AllSourcesResponse,
    AllSourcesError,
    InfiniteData<AllSourcesResponse>,
    QueryKey<Options<AllSourcesData>>,
    | number
    | Pick<
        QueryKey<Options<AllSourcesData>>[0],
        'body' | 'headers' | 'path' | 'query'
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<AllSourcesData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  offset: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await allSources({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: allSourcesInfiniteQueryKey(options),
    }
  );
};

export const searchSourceQueryKey = (options: Options<SearchSourceData>) =>
  createQueryKey('searchSource', options);

/**
 * Search Source
 * Search sources with a certain address.
 */
export const searchSourceOptions = (options: Options<SearchSourceData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await searchSource({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: searchSourceQueryKey(options),
  });
};

export const searchSourceInfiniteQueryKey = (
  options: Options<SearchSourceData>
): QueryKey<Options<SearchSourceData>> =>
  createQueryKey('searchSource', options, true);

/**
 * Search Source
 * Search sources with a certain address.
 */
export const searchSourceInfiniteOptions = (
  options: Options<SearchSourceData>
) => {
  return infiniteQueryOptions<
    SearchSourceResponse,
    SearchSourceError,
    InfiniteData<SearchSourceResponse>,
    QueryKey<Options<SearchSourceData>>,
    | number
    | Pick<
        QueryKey<Options<SearchSourceData>>[0],
        'body' | 'headers' | 'path' | 'query'
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<SearchSourceData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                body: {
                  offset: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await searchSource({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: searchSourceInfiniteQueryKey(options),
    }
  );
};

/**
 * Search Source
 * Search sources with a certain address.
 */
export const searchSourceMutation = (
  options?: Partial<Options<SearchSourceData>>
): UseMutationOptions<
  SearchSourceResponse,
  SearchSourceError,
  Options<SearchSourceData>
> => {
  const mutationOptions: UseMutationOptions<
    SearchSourceResponse,
    SearchSourceError,
    Options<SearchSourceData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await searchSource({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getSourceByIdQueryKey = (options: Options<GetSourceByIdData>) =>
  createQueryKey('getSourceById', options);

/**
 * Get Source By Id
 * Get an source by ID.
 */
export const getSourceByIdOptions = (options: Options<GetSourceByIdData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getSourceById({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getSourceByIdQueryKey(options),
  });
};

/**
 * Update Source
 * Update an sources by ID.
 */
export const updateSourceMutation = (
  options?: Partial<Options<UpdateSourceData>>
): UseMutationOptions<
  UpdateSourceResponse,
  UpdateSourceError,
  Options<UpdateSourceData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateSourceResponse,
    UpdateSourceError,
    Options<UpdateSourceData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await updateSource({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getSourceAdminsByIdQueryKey = (
  options: Options<GetSourceAdminsByIdData>
) => createQueryKey('getSourceAdminsById', options);

/**
 * Get Source Admins By Id
 * Get all administrators of an source.
 */
export const getSourceAdminsByIdOptions = (
  options: Options<GetSourceAdminsByIdData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getSourceAdminsById({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getSourceAdminsByIdQueryKey(options),
  });
};

export const getSourceContactByIdQueryKey = (
  options: Options<GetSourceContactByIdData>
) => createQueryKey('getSourceContactById', options);

/**
 * Get Source Contact By Id
 * Get an sources internal contact.
 */
export const getSourceContactByIdOptions = (
  options: Options<GetSourceContactByIdData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getSourceContactById({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getSourceContactByIdQueryKey(options),
  });
};

/**
 * Update Source Admin
 * Update an sources approval status.
 */
export const updateSourceAdminMutation = (
  options?: Partial<Options<UpdateSourceAdminData>>
): UseMutationOptions<
  UpdateSourceAdminResponse,
  UpdateSourceAdminError,
  Options<UpdateSourceAdminData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateSourceAdminResponse,
    UpdateSourceAdminError,
    Options<UpdateSourceAdminData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await updateSourceAdmin({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Add Source Admin
 * Add an admin to an source.
 */
export const addSourceAdminMutation = (
  options?: Partial<Options<AddSourceAdminData>>
): UseMutationOptions<
  AddSourceAdminResponse,
  AddSourceAdminError,
  Options<AddSourceAdminData>
> => {
  const mutationOptions: UseMutationOptions<
    AddSourceAdminResponse,
    AddSourceAdminError,
    Options<AddSourceAdminData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await addSourceAdmin({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Remove Source Admin
 * Remove an admin from an source.
 */
export const removeSourceAdminMutation = (
  options?: Partial<Options<RemoveSourceAdminData>>
): UseMutationOptions<
  RemoveSourceAdminResponse,
  RemoveSourceAdminError,
  Options<RemoveSourceAdminData>
> => {
  const mutationOptions: UseMutationOptions<
    RemoveSourceAdminResponse,
    RemoveSourceAdminError,
    Options<RemoveSourceAdminData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await removeSourceAdmin({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const futureEventsQueryKey = (options: Options<FutureEventsData>) =>
  createQueryKey('futureEvents', options);

/**
 * Future Events
 * Get the 25 next events an source organised.
 */
export const futureEventsOptions = (options: Options<FutureEventsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await futureEvents({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: futureEventsQueryKey(options),
  });
};

export const futureEventsInfiniteQueryKey = (
  options: Options<FutureEventsData>
): QueryKey<Options<FutureEventsData>> =>
  createQueryKey('futureEvents', options, true);

/**
 * Future Events
 * Get the 25 next events an source organised.
 */
export const futureEventsInfiniteOptions = (
  options: Options<FutureEventsData>
) => {
  return infiniteQueryOptions<
    FutureEventsResponse,
    FutureEventsError,
    InfiniteData<FutureEventsResponse>,
    QueryKey<Options<FutureEventsData>>,
    | number
    | Pick<
        QueryKey<Options<FutureEventsData>>[0],
        'body' | 'headers' | 'path' | 'query'
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<FutureEventsData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  offset: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await futureEvents({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: futureEventsInfiniteQueryKey(options),
    }
  );
};

export const pastEventsQueryKey = (options: Options<PastEventsData>) =>
  createQueryKey('pastEvents', options);

/**
 * Past Events
 * Get the most recent 25 events an source organised.
 */
export const pastEventsOptions = (options: Options<PastEventsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await pastEvents({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: pastEventsQueryKey(options),
  });
};

export const pastEventsInfiniteQueryKey = (
  options: Options<PastEventsData>
): QueryKey<Options<PastEventsData>> =>
  createQueryKey('pastEvents', options, true);

/**
 * Past Events
 * Get the most recent 25 events an source organised.
 */
export const pastEventsInfiniteOptions = (options: Options<PastEventsData>) => {
  return infiniteQueryOptions<
    PastEventsResponse,
    PastEventsError,
    InfiniteData<PastEventsResponse>,
    QueryKey<Options<PastEventsData>>,
    | number
    | Pick<
        QueryKey<Options<PastEventsData>>[0],
        'body' | 'headers' | 'path' | 'query'
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<PastEventsData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  offset: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await pastEvents({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: pastEventsInfiniteQueryKey(options),
    }
  );
};

export const editableEventsQueryKey = (options: Options<EditableEventsData>) =>
  createQueryKey('editableEvents', options);

/**
 * Editable Events
 * Get all editable events.
 */
export const editableEventsOptions = (options: Options<EditableEventsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await editableEvents({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: editableEventsQueryKey(options),
  });
};

export const editableEventsInfiniteQueryKey = (
  options: Options<EditableEventsData>
): QueryKey<Options<EditableEventsData>> =>
  createQueryKey('editableEvents', options, true);

/**
 * Editable Events
 * Get all editable events.
 */
export const editableEventsInfiniteOptions = (
  options: Options<EditableEventsData>
) => {
  return infiniteQueryOptions<
    EditableEventsResponse,
    EditableEventsError,
    InfiniteData<EditableEventsResponse>,
    QueryKey<Options<EditableEventsData>>,
    | number
    | Pick<
        QueryKey<Options<EditableEventsData>>[0],
        'body' | 'headers' | 'path' | 'query'
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<EditableEventsData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  offset: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await editableEvents({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: editableEventsInfiniteQueryKey(options),
    }
  );
};

export const getSourceTitleImageQueryKey = (
  options: Options<GetSourceTitleImageData>
) => createQueryKey('getSourceTitleImage', options);

/**
 * Get Source Title Image
 * Get an image by name.
 *
 * Args:
 * source_id: The id of the source to get the title image from.
 * grid_fs_manager: A loaded GridFSManager.
 * session: A loaded PostgreSQLSession.
 *
 * Returns:
 * StreamingResponse: The image from the database.
 */
export const getSourceTitleImageOptions = (
  options: Options<GetSourceTitleImageData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getSourceTitleImage({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getSourceTitleImageQueryKey(options),
  });
};

export const upsertTitleImageQueryKey = (
  options: Options<UpsertTitleImageData>
) => createQueryKey('upsertTitleImage', options);

/**
 * Upsert Title Image
 * Upload a new image.
 *
 * Args:
 * source_id: The id of the source to upsert the title image from.
 * file_data: The image data.
 * current_active_user: A logged-in user.
 * grid_fs_manager: A loaded GridFSManager.
 * session: A loaded PostgreSQLSession.
 *
 * Returns:
 * dict[str, str]: A dictionary containing the 'image_name'.
 */
export const upsertTitleImageOptions = (
  options: Options<UpsertTitleImageData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await upsertTitleImage({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: upsertTitleImageQueryKey(options),
  });
};

/**
 * Upsert Title Image
 * Upload a new image.
 *
 * Args:
 * source_id: The id of the source to upsert the title image from.
 * file_data: The image data.
 * current_active_user: A logged-in user.
 * grid_fs_manager: A loaded GridFSManager.
 * session: A loaded PostgreSQLSession.
 *
 * Returns:
 * dict[str, str]: A dictionary containing the 'image_name'.
 */
export const upsertTitleImageMutation = (
  options?: Partial<Options<UpsertTitleImageData>>
): UseMutationOptions<
  UpsertTitleImageResponse,
  UpsertTitleImageError,
  Options<UpsertTitleImageData>
> => {
  const mutationOptions: UseMutationOptions<
    UpsertTitleImageResponse,
    UpsertTitleImageError,
    Options<UpsertTitleImageData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await upsertTitleImage({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const allSourceTypesQueryKey = (options?: Options<AllSourceTypesData>) =>
  createQueryKey('allSourceTypes', options);

/**
 * All Source Types
 * Get all source types.
 */
export const allSourceTypesOptions = (
  options?: Options<AllSourceTypesData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await allSourceTypes({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: allSourceTypesQueryKey(options),
  });
};

export const newSourceTypeQueryKey = (options: Options<NewSourceTypeData>) =>
  createQueryKey('newSourceType', options);

/**
 * New Source Type
 * Create a new source type.
 */
export const newSourceTypeOptions = (options: Options<NewSourceTypeData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await newSourceType({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: newSourceTypeQueryKey(options),
  });
};

/**
 * New Source Type
 * Create a new source type.
 */
export const newSourceTypeMutation = (
  options?: Partial<Options<NewSourceTypeData>>
): UseMutationOptions<
  NewSourceTypeResponse,
  NewSourceTypeError,
  Options<NewSourceTypeData>
> => {
  const mutationOptions: UseMutationOptions<
    NewSourceTypeResponse,
    NewSourceTypeError,
    Options<NewSourceTypeData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await newSourceType({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getSourceTypeByIdQueryKey = (
  options: Options<GetSourceTypeByIdData>
) => createQueryKey('getSourceTypeById', options);

/**
 * Get Source Type By Id
 * Update an source type by ID.
 */
export const getSourceTypeByIdOptions = (
  options: Options<GetSourceTypeByIdData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getSourceTypeById({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getSourceTypeByIdQueryKey(options),
  });
};

/**
 * Update Source Type
 * Get an source type by ID.
 */
export const updateSourceTypeMutation = (
  options?: Partial<Options<UpdateSourceTypeData>>
): UseMutationOptions<
  UpdateSourceTypeResponse,
  UpdateSourceTypeError,
  Options<UpdateSourceTypeData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateSourceTypeResponse,
    UpdateSourceTypeError,
    Options<UpdateSourceTypeData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await updateSourceType({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete Source Type By Id
 * Delete an source type by ID.
 */
export const deleteSourceTypeByIdMutation = (
  options?: Partial<Options<DeleteSourceTypeByIdData>>
): UseMutationOptions<
  DeleteSourceTypeByIdResponse,
  DeleteSourceTypeByIdError,
  Options<DeleteSourceTypeByIdData>
> => {
  const mutationOptions: UseMutationOptions<
    DeleteSourceTypeByIdResponse,
    DeleteSourceTypeByIdError,
    Options<DeleteSourceTypeByIdData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await deleteSourceTypeById({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const allTopicsQueryKey = (options?: Options<AllTopicsData>) =>
  createQueryKey('allTopics', options);

/**
 * All Topics
 * Get all topics.
 */
export const allTopicsOptions = (options?: Options<AllTopicsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await allTopics({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: allTopicsQueryKey(options),
  });
};

export const newTopicQueryKey = (options: Options<NewTopicData>) =>
  createQueryKey('newTopic', options);

/**
 * New Topic
 * Create a new topic.
 */
export const newTopicOptions = (options: Options<NewTopicData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await newTopic({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: newTopicQueryKey(options),
  });
};

/**
 * New Topic
 * Create a new topic.
 */
export const newTopicMutation = (
  options?: Partial<Options<NewTopicData>>
): UseMutationOptions<
  NewTopicResponse,
  NewTopicError,
  Options<NewTopicData>
> => {
  const mutationOptions: UseMutationOptions<
    NewTopicResponse,
    NewTopicError,
    Options<NewTopicData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await newTopic({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Update Topic
 * Update a topic by ID.
 */
export const updateTopicMutation = (
  options?: Partial<Options<UpdateTopicData>>
): UseMutationOptions<
  UpdateTopicResponse,
  UpdateTopicError,
  Options<UpdateTopicData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateTopicResponse,
    UpdateTopicError,
    Options<UpdateTopicData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await updateTopic({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete Topic By Id
 * Get a topic by ID.
 */
export const deleteTopicByIdMutation = (
  options?: Partial<Options<DeleteTopicByIdData>>
): UseMutationOptions<
  DeleteTopicByIdResponse,
  DeleteTopicByIdError,
  Options<DeleteTopicByIdData>
> => {
  const mutationOptions: UseMutationOptions<
    DeleteTopicByIdResponse,
    DeleteTopicByIdError,
    Options<DeleteTopicByIdData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await deleteTopicById({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getTopicByIdQueryKey = (options: Options<GetTopicByIdData>) =>
  createQueryKey('getTopicById', options);

/**
 * Get Topic By Id
 * Get a topic by ID.
 */
export const getTopicByIdOptions = (options: Options<GetTopicByIdData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getTopicById({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getTopicByIdQueryKey(options),
  });
};

export const allInformationQueryKey = (options?: Options<AllInformationData>) =>
  createQueryKey('allInformation', options);

/**
 * All Information
 * Get all information.
 */
export const allInformationOptions = (
  options?: Options<AllInformationData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await allInformation({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: allInformationQueryKey(options),
  });
};

/**
 * All Information
 * Get all information.
 */
export const allInformationMutation = (
  options?: Partial<Options<AllInformationData>>
): UseMutationOptions<
  AllInformationResponse,
  DefaultError,
  Options<AllInformationData>
> => {
  const mutationOptions: UseMutationOptions<
    AllInformationResponse,
    DefaultError,
    Options<AllInformationData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await allInformation({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const newInformationQueryKey = (options: Options<NewInformationData>) =>
  createQueryKey('newInformation', options);

/**
 * New Information
 * Create a new information entry.
 */
export const newInformationOptions = (options: Options<NewInformationData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await newInformation({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: newInformationQueryKey(options),
  });
};

/**
 * New Information
 * Create a new information entry.
 */
export const newInformationMutation = (
  options?: Partial<Options<NewInformationData>>
): UseMutationOptions<
  NewInformationResponse,
  NewInformationError,
  Options<NewInformationData>
> => {
  const mutationOptions: UseMutationOptions<
    NewInformationResponse,
    NewInformationError,
    Options<NewInformationData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await newInformation({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getAvailableCitiesQueryKey = (
  options?: Options<GetAvailableCitiesData>
) => createQueryKey('getAvailableCities', options);

/**
 * Get Available Cities
 * Get all available cities for which information are available.
 */
export const getAvailableCitiesOptions = (
  options?: Options<GetAvailableCitiesData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getAvailableCities({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getAvailableCitiesQueryKey(options),
  });
};

export const findInformationQueryKey = (
  options: Options<FindInformationData>
) => createQueryKey('findInformation', options);

/**
 * Find Information
 * Find information for certain cities or countries.
 */
export const findInformationOptions = (
  options: Options<FindInformationData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await findInformation({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: findInformationQueryKey(options),
  });
};

export const findInformationInfiniteQueryKey = (
  options: Options<FindInformationData>
): QueryKey<Options<FindInformationData>> =>
  createQueryKey('findInformation', options, true);

/**
 * Find Information
 * Find information for certain cities or countries.
 */
export const findInformationInfiniteOptions = (
  options: Options<FindInformationData>
) => {
  return infiniteQueryOptions<
    FindInformationResponse,
    FindInformationError,
    InfiniteData<FindInformationResponse>,
    QueryKey<Options<FindInformationData>>,
    | number
    | Pick<
        QueryKey<Options<FindInformationData>>[0],
        'body' | 'headers' | 'path' | 'query'
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<FindInformationData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                body: {
                  offset: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await findInformation({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: findInformationInfiniteQueryKey(options),
    }
  );
};

/**
 * Find Information
 * Find information for certain cities or countries.
 */
export const findInformationMutation = (
  options?: Partial<Options<FindInformationData>>
): UseMutationOptions<
  FindInformationResponse,
  FindInformationError,
  Options<FindInformationData>
> => {
  const mutationOptions: UseMutationOptions<
    FindInformationResponse,
    FindInformationError,
    Options<FindInformationData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await findInformation({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete Information
 * Delete an information by ID.
 */
export const deleteInformationMutation = (
  options?: Partial<Options<DeleteInformationData>>
): UseMutationOptions<
  DeleteInformationResponse,
  DeleteInformationError,
  Options<DeleteInformationData>
> => {
  const mutationOptions: UseMutationOptions<
    DeleteInformationResponse,
    DeleteInformationError,
    Options<DeleteInformationData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await deleteInformation({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Update Information
 * Update an information by ID.
 */
export const updateInformationMutation = (
  options?: Partial<Options<UpdateInformationData>>
): UseMutationOptions<
  UpdateInformationResponse,
  UpdateInformationError,
  Options<UpdateInformationData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateInformationResponse,
    UpdateInformationError,
    Options<UpdateInformationData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await updateInformation({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getAccessTokenByLoginQueryKey = (
  options: Options<GetAccessTokenByLoginData>
) => createQueryKey('getAccessTokenByLogin', options);

/**
 * Get Access Token By Login
 * Retrieve an access token for the API by logging in.
 *
 * Args:
 * form_data: The login form data.
 * config: The applications' configuration.
 * session: The database Session.
 */
export const getAccessTokenByLoginOptions = (
  options: Options<GetAccessTokenByLoginData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getAccessTokenByLogin({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getAccessTokenByLoginQueryKey(options),
  });
};

/**
 * Get Access Token By Login
 * Retrieve an access token for the API by logging in.
 *
 * Args:
 * form_data: The login form data.
 * config: The applications' configuration.
 * session: The database Session.
 */
export const getAccessTokenByLoginMutation = (
  options?: Partial<Options<GetAccessTokenByLoginData>>
): UseMutationOptions<
  GetAccessTokenByLoginResponse,
  GetAccessTokenByLoginError,
  Options<GetAccessTokenByLoginData>
> => {
  const mutationOptions: UseMutationOptions<
    GetAccessTokenByLoginResponse,
    GetAccessTokenByLoginError,
    Options<GetAccessTokenByLoginData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await getAccessTokenByLogin({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getAccessTokenByTokenQueryKey = (
  options?: Options<GetAccessTokenByTokenData>
) => createQueryKey('getAccessTokenByToken', options);

/**
 * Get Access Token By Token
 * Retrieve an access token for the API with a currently active token.
 */
export const getAccessTokenByTokenOptions = (
  options?: Options<GetAccessTokenByTokenData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getAccessTokenByToken({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getAccessTokenByTokenQueryKey(options),
  });
};

export const resetPasswordQueryKey = (options: Options<ResetPasswordData>) =>
  createQueryKey('resetPassword', options);

/**
 * Reset Password
 * Reset a user's password.
 */
export const resetPasswordOptions = (options: Options<ResetPasswordData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await resetPassword({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: resetPasswordQueryKey(options),
  });
};

/**
 * Reset Password
 * Reset a user's password.
 */
export const resetPasswordMutation = (
  options?: Partial<Options<ResetPasswordData>>
): UseMutationOptions<
  ResetPasswordResponse,
  ResetPasswordError,
  Options<ResetPasswordData>
> => {
  const mutationOptions: UseMutationOptions<
    ResetPasswordResponse,
    ResetPasswordError,
    Options<ResetPasswordData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await resetPassword({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete Own User
 * Delete own account.
 */
export const deleteOwnUserMutation = (
  options?: Partial<Options<DeleteOwnUserData>>
): UseMutationOptions<
  DeleteOwnUserResponse,
  DefaultError,
  Options<DeleteOwnUserData>
> => {
  const mutationOptions: UseMutationOptions<
    DeleteOwnUserResponse,
    DefaultError,
    Options<DeleteOwnUserData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await deleteOwnUser({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getOwnUserQueryKey = (options?: Options<GetOwnUserData>) =>
  createQueryKey('getOwnUser', options);

/**
 * Get Own User
 * Get own user information.
 */
export const getOwnUserOptions = (options?: Options<GetOwnUserData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getOwnUser({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getOwnUserQueryKey(options),
  });
};

/**
 * Update Own User
 * Update own user data.
 */
export const updateOwnUserMutation = (
  options?: Partial<Options<UpdateOwnUserData>>
): UseMutationOptions<
  UpdateOwnUserResponse,
  UpdateOwnUserError,
  Options<UpdateOwnUserData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateOwnUserResponse,
    UpdateOwnUserError,
    Options<UpdateOwnUserData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await updateOwnUser({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getOwnSourcesQueryKey = (options?: Options<GetOwnSourcesData>) =>
  createQueryKey('getOwnSources', options);

/**
 * Get Own Sources
 * Get own administrated sources.
 */
export const getOwnSourcesOptions = (options?: Options<GetOwnSourcesData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getOwnSources({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getOwnSourcesQueryKey(options),
  });
};

export const getAdminIdsQueryKey = (options?: Options<GetAdminIdsData>) =>
  createQueryKey('getAdminIds', options);

/**
 * Get Admin Ids
 * Get all administrations of the application.
 */
export const getAdminIdsOptions = (options?: Options<GetAdminIdsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getAdminIds({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getAdminIdsQueryKey(options),
  });
};

export const makeAdminQueryKey = (options: Options<MakeAdminData>) =>
  createQueryKey('makeAdmin', options);

/**
 * Make Admin
 * Make a user an application admin.
 */
export const makeAdminOptions = (options: Options<MakeAdminData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await makeAdmin({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: makeAdminQueryKey(options),
  });
};

/**
 * Make Admin
 * Make a user an application admin.
 */
export const makeAdminMutation = (
  options?: Partial<Options<MakeAdminData>>
): UseMutationOptions<
  MakeAdminResponse,
  MakeAdminError,
  Options<MakeAdminData>
> => {
  const mutationOptions: UseMutationOptions<
    MakeAdminResponse,
    MakeAdminError,
    Options<MakeAdminData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await makeAdmin({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getUserByIdQueryKey = (options: Options<GetUserByIdData>) =>
  createQueryKey('getUserById', options);

/**
 * Get User By Id
 * Get a user's data by ID.
 */
export const getUserByIdOptions = (options: Options<GetUserByIdData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getUserById({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getUserByIdQueryKey(options),
  });
};

/**
 * Update User By Id
 * Update a user's data by ID.
 */
export const updateUserByIdMutation = (
  options?: Partial<Options<UpdateUserByIdData>>
): UseMutationOptions<
  UpdateUserByIdResponse,
  UpdateUserByIdError,
  Options<UpdateUserByIdData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateUserByIdResponse,
    UpdateUserByIdError,
    Options<UpdateUserByIdData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await updateUserById({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getSearchLanguagesQueryKey = (
  options?: Options<GetSearchLanguagesData>
) => createQueryKey('getSearchLanguages', options);

/**
 * Get Search Languages
 * List all supported languages.
 */
export const getSearchLanguagesOptions = (
  options?: Options<GetSearchLanguagesData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getSearchLanguages({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getSearchLanguagesQueryKey(options),
  });
};

export const getAvailableDocumentsQueryKey = (
  options?: Options<GetAvailableDocumentsData>
) => createQueryKey('getAvailableDocuments', options);

/**
 * Get Available Documents
 * Get all available documents.
 *
 * Returns:
 * dict[str, str]: All names of available documents.
 */
export const getAvailableDocumentsOptions = (
  options?: Options<GetAvailableDocumentsData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getAvailableDocuments({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getAvailableDocumentsQueryKey(options),
  });
};

/**
 * Delete Document By Id
 * Delete a document by file name.
 *
 * Args:
 * document_id: The id of the document.
 * current_active_superuser: A logged-in superuser.
 * grid_fs_manager: A loaded GridFSManager.
 * session: A loaded PostgreSQLSession.
 *
 * Returns:
 * str: If the request was successful
 */
export const deleteDocumentByIdMutation = (
  options?: Partial<Options<DeleteDocumentByIdData>>
): UseMutationOptions<
  DeleteDocumentByIdResponse,
  DeleteDocumentByIdError,
  Options<DeleteDocumentByIdData>
> => {
  const mutationOptions: UseMutationOptions<
    DeleteDocumentByIdResponse,
    DeleteDocumentByIdError,
    Options<DeleteDocumentByIdData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await deleteDocumentById({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getDocumentByIdQueryKey = (
  options: Options<GetDocumentByIdData>
) => createQueryKey('getDocumentById', options);

/**
 * Get Document By Id
 * Get a document by file name.
 *
 * Args:
 * document_id: The id of the document.
 * grid_fs_manager: A loaded GridFSManager.
 * session: A loaded PostgreSQLSession.
 *
 * Returns:
 * StreamingResponse: The document from the database.
 */
export const getDocumentByIdOptions = (
  options: Options<GetDocumentByIdData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getDocumentById({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getDocumentByIdQueryKey(options),
  });
};

export const uploadDocumentQueryKey = (options: Options<UploadDocumentData>) =>
  createQueryKey('uploadDocument', options);

/**
 * Upload Document
 * Upload a new document.
 *
 * Args:
 * language: The language of the file.
 * document_type: The type of the document (e.g. financial report)
 * file_data: The document data.
 * current_active_superuser: A logged-in superuser.
 * display_name: The name to show in the UI.
 * grid_fs_manager: A loaded GridFSManager.
 * session: A loaded PostgreSQLSession.
 *
 * Returns:
 * str: A status response
 */
export const uploadDocumentOptions = (options: Options<UploadDocumentData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await uploadDocument({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: uploadDocumentQueryKey(options),
  });
};

/**
 * Upload Document
 * Upload a new document.
 *
 * Args:
 * language: The language of the file.
 * document_type: The type of the document (e.g. financial report)
 * file_data: The document data.
 * current_active_superuser: A logged-in superuser.
 * display_name: The name to show in the UI.
 * grid_fs_manager: A loaded GridFSManager.
 * session: A loaded PostgreSQLSession.
 *
 * Returns:
 * str: A status response
 */
export const uploadDocumentMutation = (
  options?: Partial<Options<UploadDocumentData>>
): UseMutationOptions<
  UploadDocumentResponse,
  UploadDocumentError,
  Options<UploadDocumentData>
> => {
  const mutationOptions: UseMutationOptions<
    UploadDocumentResponse,
    UploadDocumentError,
    Options<UploadDocumentData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await uploadDocument({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getEventAnalysisQueryKey = (
  options: Options<GetEventAnalysisData>
) => createQueryKey('getEventAnalysis', options);

/**
 * Get Event Analysis
 * Get event data for densitymaps.
 */
export const getEventAnalysisOptions = (
  options: Options<GetEventAnalysisData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getEventAnalysis({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getEventAnalysisQueryKey(options),
  });
};

/**
 * Get Event Analysis
 * Get event data for densitymaps.
 */
export const getEventAnalysisMutation = (
  options?: Partial<Options<GetEventAnalysisData>>
): UseMutationOptions<
  GetEventAnalysisResponse,
  GetEventAnalysisError,
  Options<GetEventAnalysisData>
> => {
  const mutationOptions: UseMutationOptions<
    GetEventAnalysisResponse,
    GetEventAnalysisError,
    Options<GetEventAnalysisData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await getEventAnalysis({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const readApplicationSettingsQueryKey = (
  options?: Options<ReadApplicationSettingsData>
) => createQueryKey('readApplicationSettings', options);

/**
 * Read Application Settings
 * Read the current application settings.
 */
export const readApplicationSettingsOptions = (
  options?: Options<ReadApplicationSettingsData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await readApplicationSettings({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: readApplicationSettingsQueryKey(options),
  });
};

/**
 * Update Application Settings
 * Update the current application settings.
 */
export const updateApplicationSettingsMutation = (
  options?: Partial<Options<UpdateApplicationSettingsData>>
): UseMutationOptions<
  UpdateApplicationSettingsResponse,
  UpdateApplicationSettingsError,
  Options<UpdateApplicationSettingsData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateApplicationSettingsResponse,
    UpdateApplicationSettingsError,
    Options<UpdateApplicationSettingsData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await updateApplicationSettings({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getAdminStatisticsQueryKey = (
  options?: Options<GetAdminStatisticsData>
) => createQueryKey('getAdminStatistics', options);

/**
 * Get Admin Statistics
 * Get statistics for the admin.
 */
export const getAdminStatisticsOptions = (
  options?: Options<GetAdminStatisticsData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getAdminStatistics({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getAdminStatisticsQueryKey(options),
  });
};

/**
 * Get Admin Statistics
 * Get statistics for the admin.
 */
export const getAdminStatisticsMutation = (
  options?: Partial<Options<GetAdminStatisticsData>>
): UseMutationOptions<
  GetAdminStatisticsResponse,
  DefaultError,
  Options<GetAdminStatisticsData>
> => {
  const mutationOptions: UseMutationOptions<
    GetAdminStatisticsResponse,
    DefaultError,
    Options<GetAdminStatisticsData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await getAdminStatistics({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const runCleanupQueryKey = (options: Options<RunCleanupData>) =>
  createQueryKey('runCleanup', options);

/**
 * Run Cleanup
 * Perform cleanup tasks.
 */
export const runCleanupOptions = (options: Options<RunCleanupData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await runCleanup({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: runCleanupQueryKey(options),
  });
};

/**
 * Run Cleanup
 * Perform cleanup tasks.
 */
export const runCleanupMutation = (
  options?: Partial<Options<RunCleanupData>>
): UseMutationOptions<
  RunCleanupResponse,
  RunCleanupError,
  Options<RunCleanupData>
> => {
  const mutationOptions: UseMutationOptions<
    RunCleanupResponse,
    RunCleanupError,
    Options<RunCleanupData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await runCleanup({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const trainQueryKey = (options?: Options<TrainData>) =>
  createQueryKey('train', options);

/**
 * Train
 * Perform cleanup tasks.
 */
export const trainOptions = (options?: Options<TrainData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await train({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: trainQueryKey(options),
  });
};

export const getQuickTagEventQueryKey = (
  options: Options<GetQuickTagEventData>
) => createQueryKey('getQuickTagEvent', options);

/**
 * Get Quick Tag Event
 * Get an Event for quick tagging.
 */
export const getQuickTagEventOptions = (
  options: Options<GetQuickTagEventData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getQuickTagEvent({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getQuickTagEventQueryKey(options),
  });
};

/**
 * Get Quick Tag Event
 * Get an Event for quick tagging.
 */
export const getQuickTagEventMutation = (
  options?: Partial<Options<GetQuickTagEventData>>
): UseMutationOptions<
  GetQuickTagEventResponse,
  GetQuickTagEventError,
  Options<GetQuickTagEventData>
> => {
  const mutationOptions: UseMutationOptions<
    GetQuickTagEventResponse,
    GetQuickTagEventError,
    Options<GetQuickTagEventData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await getQuickTagEvent({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const quickTagEventQueryKey = (options: Options<QuickTagEventData>) =>
  createQueryKey('quickTagEvent', options);

/**
 * Quick Tag Event
 * Get an Event for quick tagging.
 */
export const quickTagEventOptions = (options: Options<QuickTagEventData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await quickTagEvent({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: quickTagEventQueryKey(options),
  });
};

/**
 * Quick Tag Event
 * Get an Event for quick tagging.
 */
export const quickTagEventMutation = (
  options?: Partial<Options<QuickTagEventData>>
): UseMutationOptions<
  QuickTagEventResponse,
  QuickTagEventError,
  Options<QuickTagEventData>
> => {
  const mutationOptions: UseMutationOptions<
    QuickTagEventResponse,
    QuickTagEventError,
    Options<QuickTagEventData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await quickTagEvent({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const uploadExcelQueryKey = (options: Options<UploadExcelData>) =>
  createQueryKey('uploadExcel', options);

/**
 * Upload Excel
 * Upload excel data.
 *
 * Time format is Python formatting. (https://docs.python.org/3/library/datetime.html#strftime-and-strptime-behavior)
 */
export const uploadExcelOptions = (options: Options<UploadExcelData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await uploadExcel({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: uploadExcelQueryKey(options),
  });
};

/**
 * Upload Excel
 * Upload excel data.
 *
 * Time format is Python formatting. (https://docs.python.org/3/library/datetime.html#strftime-and-strptime-behavior)
 */
export const uploadExcelMutation = (
  options?: Partial<Options<UploadExcelData>>
): UseMutationOptions<
  UploadExcelResponse,
  UploadExcelError,
  Options<UploadExcelData>
> => {
  const mutationOptions: UseMutationOptions<
    UploadExcelResponse,
    UploadExcelError,
    Options<UploadExcelData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await uploadExcel({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const dumpEventsQueryKey = (options?: Options<DumpEventsData>) =>
  createQueryKey('dumpEvents', options);

/**
 * Dump Events
 * Upload excel data.
 *
 * Time format is Python formatting. (https://docs.python.org/3/library/datetime.html#strftime-and-strptime-behavior)
 */
export const dumpEventsOptions = (options?: Options<DumpEventsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await dumpEvents({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: dumpEventsQueryKey(options),
  });
};

export const getEventIcsQueryKey = (options: Options<GetEventIcsData>) =>
  createQueryKey('getEventIcs', options);

/**
 * Get Event Ics
 * Get calendar export for specific event.
 */
export const getEventIcsOptions = (options: Options<GetEventIcsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getEventIcs({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getEventIcsQueryKey(options),
  });
};

export const getEventsIcsQueryKey = (options?: Options<GetEventsIcsData>) =>
  createQueryKey('getEventsIcs', options);

/**
 * Get Events Ics
 * Get calendar export by query.
 */
export const getEventsIcsOptions = (options?: Options<GetEventsIcsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getEventsIcs({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getEventsIcsQueryKey(options),
  });
};

export const getEventsIcsInfiniteQueryKey = (
  options?: Options<GetEventsIcsData>
): QueryKey<Options<GetEventsIcsData>> =>
  createQueryKey('getEventsIcs', options, true);

/**
 * Get Events Ics
 * Get calendar export by query.
 */
export const getEventsIcsInfiniteOptions = (
  options?: Options<GetEventsIcsData>
) => {
  return infiniteQueryOptions<
    GetEventsIcsResponse,
    GetEventsIcsError,
    InfiniteData<GetEventsIcsResponse>,
    QueryKey<Options<GetEventsIcsData>>,
    | number
    | Pick<
        QueryKey<Options<GetEventsIcsData>>[0],
        'body' | 'headers' | 'path' | 'query'
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetEventsIcsData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  offset: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getEventsIcs({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getEventsIcsInfiniteQueryKey(options),
    }
  );
};

export const getRssFeedQueryKey = (options: Options<GetRssFeedData>) =>
  createQueryKey('getRssFeed', options);

/**
 * Get Rss Feed
 * Get rss feed export by query.
 */
export const getRssFeedOptions = (options: Options<GetRssFeedData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getRssFeed({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getRssFeedQueryKey(options),
  });
};

export const getRssFeedInfiniteQueryKey = (
  options: Options<GetRssFeedData>
): QueryKey<Options<GetRssFeedData>> =>
  createQueryKey('getRssFeed', options, true);

/**
 * Get Rss Feed
 * Get rss feed export by query.
 */
export const getRssFeedInfiniteOptions = (options: Options<GetRssFeedData>) => {
  return infiniteQueryOptions<
    unknown,
    GetRssFeedError,
    InfiniteData<unknown>,
    QueryKey<Options<GetRssFeedData>>,
    | number
    | Pick<
        QueryKey<Options<GetRssFeedData>>[0],
        'body' | 'headers' | 'path' | 'query'
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetRssFeedData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  offset: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getRssFeed({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getRssFeedInfiniteQueryKey(options),
    }
  );
};

export const getStaticsSitemapQueryKey = (
  options?: Options<GetStaticsSitemapData>
) => createQueryKey('getStaticsSitemap', options);

/**
 * Get Statics Sitemap
 * Get the sitemap index.
 */
export const getStaticsSitemapOptions = (
  options?: Options<GetStaticsSitemapData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getStaticsSitemap({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getStaticsSitemapQueryKey(options),
  });
};

export const getSourcesSitemapQueryKey = (
  options?: Options<GetSourcesSitemapData>
) => createQueryKey('getSourcesSitemap', options);

/**
 * Get Sources Sitemap
 * Get the sources sitemap.
 */
export const getSourcesSitemapOptions = (
  options?: Options<GetSourcesSitemapData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getSourcesSitemap({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getSourcesSitemapQueryKey(options),
  });
};

export const getEventsSitemapIndexQueryKey = (
  options?: Options<GetEventsSitemapIndexData>
) => createQueryKey('getEventsSitemapIndex', options);

/**
 * Get Events Sitemap Index
 * Get the sitemap index.
 */
export const getEventsSitemapIndexOptions = (
  options?: Options<GetEventsSitemapIndexData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getEventsSitemapIndex({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getEventsSitemapIndexQueryKey(options),
  });
};

export const getEventsSitemapQueryKey = (
  options: Options<GetEventsSitemapData>
) => createQueryKey('getEventsSitemap', options);

/**
 * Get Events Sitemap
 * Get the events sitemap.
 */
export const getEventsSitemapOptions = (
  options: Options<GetEventsSitemapData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getEventsSitemap({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getEventsSitemapQueryKey(options),
  });
};
